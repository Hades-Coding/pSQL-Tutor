/* PostgreSQL Tutorial */
-- PostgreSQL Tutorial
-- Section 12. Managing Tables
-- https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-create-table/
-- Data types, Create a table, Select Into, Create table as
-- Auto-increment column with SERIAL, Sequences, Identity column
-- Alter table, Rename table, Add column, Drop column, Change column data type, Rename column
--   => DEFAULT can SET or DROP (eg: SET NOT NULL or DROP NOT NULL)
-- Drop table, Truncate table, Temporary table, Copy a table
--------------------------------------------------
-- Notes:
-- 03 SERIAL pseudo-types: SMALLSERIAL (2 bytes), SERIAL (4 bytes), BIGSERIAL (8 bytes) - Both unsigned!
-- 1. TEMPORARY TABLE can use TEMP or TEMPORARY keyword
-- 2. Truncate is DML (TXN based, then can ROLLBACK) <> Oracle (DDL, can not rollback)
--------------------------------------------------
\c Test

--------------------------------------------------
-- 01. SERIAL & SEQUENCE
--------------------------------------------------
-- Option 1:
CREATE TABLE table_name(
    id SERIAL
);

-- Option 2 equivalent
CREATE SEQUENCE table_name_id_seq;

CREATE TABLE table_name (
    id integer NOT NULL DEFAULT nextval('table_name_id_seq')
);

ALTER SEQUENCE table_name_id_seq
OWNED BY table_name.id;

----------
-- Example
----------
DROP TABLE IF EXISTS  fruits;
CREATE TABLE fruits(
   id SERIAL PRIMARY KEY,
   name VARCHAR NOT NULL
);

INSERT INTO fruits(id, name) 
VALUES(DEFAULT, 'Orange'), (DEFAULT,'Apple');

/*
INSERT INTO fruits(name) 
VALUES ('Orange 2'), ('Apple 2');
*/

-- To get sequence name:
-- pg_get_serial_sequence('table_name','column_name')
SELECT currval(pg_get_serial_sequence('fruits', 'id'));

INSERT INTO fruits(name) 
VALUES('Banana')
RETURNING id;

SELECT nextval(pg_get_serial_sequence('fruits', 'id'));
SELECT currval(pg_get_serial_sequence('fruits', 'id'));

/*
CREATE SEQUENCE [ IF NOT EXISTS ] sequence_name
    [ AS { SMALLINT | INT | BIGINT } ] -- BIGINT is DEFAULT
    [ START [ WITH ] start ] 
    [ INCREMENT [ BY ] increment ]
    [ MINVALUE minvalue | NO MINVALUE ] 
    [ MAXVALUE maxvalue | NO MAXVALUE ]
    [ CACHE cache ] 
    [ [ NO ] CYCLE ]
    [ OWNED BY { table_name.column_name | NONE }]
*/

-- Creating a sequence associated with a table column
DROP TABLE IF EXISTS order_details;
CREATE TABLE order_details(
    order_id SERIAL,
    item_id INT NOT NULL,
    item_text VARCHAR NOT NULL,
    price DEC(10,2) NOT NULL,
    PRIMARY KEY(order_id, item_id)
);

-- Create & assign for 1 column
DROP SEQUENCE IF EXISTS order_item_id CASCADE;
CREATE SEQUENCE order_item_id
START 10 INCREMENT 10 MINVALUE 10
OWNED BY order_details.item_id;

INSERT INTO order_details(order_id, item_id, item_text, price)
VALUES
    (100, nextval('order_item_id'),'DVD Player',100),
    (100, nextval('order_item_id'),'Android TV',550),
    (100, nextval('order_item_id'),'Speaker',250)
RETURNING *;

-- select * from order_details;

-- Listing all sequences in a database
SELECT relname sequence_name
FROM   pg_class 
WHERE  relkind = 'S';

DROP TABLE order_details;
-- sequence related automatically droped.

--------------------------------------------------
-- 02. Identity column
--------------------------------------------------
-- column_name type GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY[ ( sequence_option ) ]
/*
type: SMALLINT, INT, or BIGINT.
GENERATED ALWAYS:
 - PostgreSQL to always generate a value for the identity column. This colum MUST declared NOT NULL.
 - If you attempt to insert (or update) values into the GENERATED ALWAYS AS IDENTITY column, PostgreSQL will issue an error.
GENERATED BY DEFAULT:
 - Also instructs PostgreSQL to generate a value for the identity column.
 - However, if you supply a value for insert or update, PostgreSQL will use that value to insert into the identity column instead of using the system-generated value.
=> PostgreSQL allows you a table to have more than one identity column. 
Like the SERIAL, the GENERATED AS IDENTITY constraint also uses the SEQUENCE object internally.
*/

/*
ALTER TABLE table_name 
	ALTER COLUMN column_name 
		ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY { ( sequence_option ) }
*/

DROP TABLE IF EXISTS shape;
CREATE TABLE shape (
    shape_id INT NOT NULL, -- must be declared NOT NULL before identity can be added
    shape_name VARCHAR NOT NULL
);

ALTER TABLE shape 
	ALTER COLUMN shape_id 
		ADD GENERATED ALWAYS AS IDENTITY;

/*
ALTER TABLE table_name 
ALTER COLUMN column_name 
{ SET GENERATED { ALWAYS| BY DEFAULT } | 
  SET sequence_option | RESTART [ [ WITH ] restart ] }
*/

/*
ALTER TABLE table_name
	ADD COLUMN column_name1 data_type constraint,
	ADD COLUMN column_name2 data_type constraint,
	...
	ADD COLUMN column_namen data_type constraint;

*/

/*
ALTER TABLE table_name
	DROP] COLUMN column_name1,
	DROP COLUMN column_name2,
	...;
*/

/*
ALTER TABLE table_name
ALTER COLUMN column_name1 [SET DATA] TYPE new_data_type,
ALTER COLUMN column_name2 [SET DATA] TYPE new_data_type,
...;
*/

DROP TABLE IF EXISTS assets;
CREATE TABLE assets (
    id serial PRIMARY KEY,
    name TEXT NOT NULL,
    asset_no VARCHAR NOT NULL,
    description TEXT,
    location TEXT,
    acquired_date DATE NOT NULL
);

INSERT INTO assets(name,asset_no,location,acquired_date)
VALUES('Server','10001','Server room','2017-01-01'),
      ('UPS','10002','Server room','2017-01-01');

ALTER TABLE assets 
	ALTER COLUMN name TYPE VARCHAR;

ALTER TABLE assets 
    ALTER COLUMN location TYPE VARCHAR,
    ALTER COLUMN description TYPE VARCHAR;

-- Error
ALTER TABLE assets 
	ALTER COLUMN asset_no TYPE INT;

-- Option 1:
ALTER TABLE assets
	ALTER COLUMN asset_no TYPE INT 
	USING asset_no::integer;

-- Option 2:
ALTER TABLE assets
	ALTER COLUMN asset_no TYPE INT 
	USING CAST (asset_no as INT);



/*
DROP TABLE [IF EXISTS] 
   table_name_1,
   table_name_2,
   ...
[CASCADE | RESTRICT];
*/

CREATE TABLE authors (
	author_id INT PRIMARY KEY,
	firstname VARCHAR (50),
	lastname VARCHAR (50)
);

CREATE TABLE pages (
	page_id serial PRIMARY KEY,
	title VARCHAR (255) NOT NULL,
	contents TEXT,
	author_id INT NOT NULL,
	FOREIGN KEY (author_id) 
          REFERENCES authors (author_id)
);


-- Can see the related FK was droped:
\d pages

DROP TABLE authors cascade;

\d pages

/*
TRUNCATE TABLE 
    table_name1, 
    table_name2,
    ...;
*/
-- TRUNCATE TABLE table_name RESTART IDENTITY;
-- TRUNCATE TABLE table_name CASCADE;

/*
PostgreSQL TRUNCATE TABLE and ON DELETE trigger
Even though the  TRUNCATE TABLE statement removes all data from a table, 
it does not fire any  ON DELETE triggers associated with the table.

To fire the trigger when the  TRUNCATE TABLE command applied to a table, 
you must define  BEFORE TRUNCATE and/or  AFTER TRUNCATE triggers for that table.

PostgreSQL TRUNCATE TABLE and transaction
The  TRUNCATE TABLE is transaction-safe. 
It means that if you place it within a transaction, you can roll it back safely.

Summary
 - Use the TRUNCATE TABLE statement to delete all data from a large table.
 - Use the CASCADE option to truncate a table and other tables that reference the table via foreign key constraint.
 - The TRUNCATE TABLE does not fire ON DELETE trigger. Instead, it fires the BEFORE TRUNCATE and AFTER TRUNCATE triggers.
 - The TRUNCATE TABLE statement is transaction-safe.
*/


/*
CREATE TEMP | TEMPORARY TABLE temp_table_name(
   column_list
);

=> Table structure only in session, not PERMANENT like Oracle
=> Don't have transaction Data like Oracle (on commit DELETE | PRESERVE rows )
=> Can have the same name with PERMANENT table,
=> After creating then can not access PERMANENT table
=> Until DROP TABLE [TEMP_TABLE] 
*/
CREATE TABLE customers(
   id SERIAL PRIMARY KEY, 
   name VARCHAR NOT NULL
);

CREATE TEMP TABLE customers(
    customer_id INT
);

SELECT * FROM customers; -- => temp table

\d customers

\d+ customers

\dt -- => Can not find PERMANENT table customers

\dt+

SELECT *
FROM pg_catalog.pg_tables
WHERE schemaname != 'pg_catalog' AND 
    schemaname != 'information_schema';

-- to access PERMANENT table customers
-- must use FQDN form (fully qualified domain name) 
SELECT * FROM public.customers;

-- DROP TEMP Table
DROP TABLE customers;

-- then can access PERMANENT table customers with out FQDN
SELECT * FROM customers;

\d customers
